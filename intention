#!/usr/bin/env bash

ACTION=$1
PROCEDURE=$2

PROTOCOL="xoscrp"
cache_file="$HOME/.cache/${PROTOCOL}"

show_init_help() {
  cat <<EOF
The script needs access to a shared directory that both Linux and Windows can access.
This is typically a mounted Windows partition or network share.

Example locations:
    /mnt/windows/          # Mounted Windows partition
    /media/user/shared/    # Shared network drive
    /home/user/shared/     # Shared directory (if using tools like Shared Folders in VM)

After initialization, place your PowerShell scripts in the procedures directory
on the Windows side, and they will be detectable by this script.
EOF
}

# ================================ [ INIT ] ================================ #

set_shared_location() {
  read -r -p 'Enter path to your shared path/mount point: ' partition
  # sanitize mount point name, ensure existence and write to cache
  [[ $partition != /* ]] && partition="/$partition"
  if [ ! -d "$partition" ]; then
    echo "Invalid mountpoint: $partition"
    exit 1
  fi
  echo "$partition" > "$cache_file"
}

# ENSURE: save windows mountpoint in cache
if [ ! -f "$cache_file" ]; then
  show_init_help
  set_shared_location
fi

get_shared_location() {
  [ ! -f "$cache_file" ] && set_shared_location
  local location
  location=$(cat "$cache_file")
  echo "$location"
}

# REQUIRED: Shared Mountpoint
shared_location=$(get_shared_location)
if [ ! -d "$shared_location" ]; then
  echo "Location does not exist: $shared_location"
  exit 1
fi

# ENSURE: shared communication and procedure directories
message_queue="${shared_location}/.${PROTOCOL}/message_queue/"
[ ! -d "${message_queue}" ] && mkdir -p "${message_queue}"

procedures="${shared_location}/.${PROTOCOL}/procedures/"
[ ! -d "${procedures}" ] && mkdir -p "${procedures}"

# =============================== [ ACTION ] =============================== #

is_procedure_available_windows() {
  [[ -f "${procedures}/${PROCEDURE}.ps1" ]] && return 0
  return 1
}

is_procedure_available_linux() {
  [[ -f "${procedures}/${PROCEDURE}.sh" ]] && return 0
  return 1
}

is_procedure_called() {
  [[ -f "${message_queue}/${PROCEDURE}" ]] && return 0
  return 1
}

get_available_procedures() {
  local proc_files
  proc_files=$(ls "${procedures}")
  for file in $proc_files; do
    if [[ $file == *.ps1 ]]; then
      echo -e "${file%.ps1}\tWindows"
    elif [[ $file == *.sh ]]; then
      echo -e "${file%.sh}\tLinux"
    else
      echo -e "${file}\tUnknown"
    fi
  done
}

show_help() {
  cat <<EOF
Cross-OS Procedure Manager

Manages procedures that run automatically when booting into Windows.
Uses shared directory: $shared_location

USAGE:
    intention [COMMAND] [PROCEDURE]

COMMANDS:
    list                    List all available procedures
    run [PROCEDURE]         Reboot to Windows and run specified procedure
    run                     Reboot to Windows without running any procedure
    set <PROCEDURE>         Mark procedure to run on next Windows boot
    unset <PROCEDURE>       Remove mark from procedure
    status <PROCEDURE>      Check if procedure is marked to run
    help                    Show this help message
    init                    Reconfigure shared location

PROCEDURES:
    Procedures are PowerShell scripts located in:
    ${procedures}
    List available procedures with 'list' command

EXAMPLES:
    intention list                 # Show available procedures
    intention run gaming_mode      # Reboot and run gaming_mode setup
    intention set gaming_mode      # Mark gaming_mode setup for next boot
    intention status gaming_mode   # Check if gaming_mode setup is scheduled
    intention unset gaming_mode    # Cancel gaming_mode setup
    intention init                 # Change shared location
EOF
}

# ============================= [ ACTION (2) ] ============================= #

# REQUIRED: ACTION
if [[ -z "$ACTION" ]]; then
  show_help
  exit 0
fi

case "$ACTION" in
"help" | "-h" | "--help")
  show_help
  exit 0
  ;;

"init")
  show_init_help
  echo ""
  set_shared_location
  echo "Shared location updated successfully."
  exit 0
  ;;

"list")
  get_available_procedures
  exit 0
  ;;

"run")
  # case: run without PROCEDURE
  if [[ -z "$PROCEDURE" ]]; then
    echo "Rebooting to Windows without running any procedure..."
    # eg $windows_title = 'Windows Boot Manager (on /dev/nvme0n1p1)'
    windows_title=$(sudo grep -i windows /boot/grub/grub.cfg | cut -d "'" -f 2)
    sudo grub-reboot "$windows_title"
    reboot
    exit 0
  fi

  # case: run with PROCEDURE
  if is_procedure_available_windows; then
    echo "Rebooting to Windows and running procedure: $PROCEDURE"
    touch "${message_queue}/${PROCEDURE}"
    # eg $windows_title = 'Windows Boot Manager (on /dev/nvme0n1p1)'
    windows_title=$(sudo grep -i windows /boot/grub/grub.cfg | cut -d "'" -f 2)
    sudo grub-reboot "$windows_title"
    reboot
    exit 0

  elif is_procedure_available_linux; then
    bash "${procedures}/${PROCEDURE}.sh"
    exit 0

  else
    echo "Error: Procedure '$PROCEDURE' is not available"
    echo "Available procedures:"
    get_available_procedures | sed 's/^/  - /'
    exit 1
  fi
  ;;
esac

# ============================= [ ACTION (3) ] ============================= #

# REQUIRED: PROCEDURE
if [[ -z "$PROCEDURE" ]]; then
  echo "Error: Procedure name is required for action '$ACTION'"
  echo ""
  show_help
  exit 1
fi

# SANITIZE: remote procedure name
if [[ ! "$PROCEDURE" =~ ^[A-Za-z0-9_-]+$ ]]; then
  echo "Error: Invalid procedure name: $PROCEDURE"
  echo "Valid characters: A-Z, a-z, 0-9, _, -"
  exit 1
fi

case "$ACTION" in
"set")
  if is_procedure_available_windows; then
    touch "${message_queue}/${PROCEDURE}"
    echo "Procedure '$PROCEDURE' scheduled for next Windows boot"
  else
    echo "Error: Procedure '$PROCEDURE' is not available"
    echo "Available procedures:"
    get_available_procedures | sed 's/^/  - /'
    exit 1
  fi
  ;;

"unset")
  if is_procedure_called; then
    rm "${message_queue}/${PROCEDURE}"
    echo "Procedure '$PROCEDURE' removed from schedule"
  else
    echo "Error: Procedure '$PROCEDURE' is not scheduled"
    exit 1
  fi
  ;;

"status")
  if is_procedure_called; then
    echo "Procedure '$PROCEDURE' is scheduled to run on next Windows boot"
  else
    echo "Procedure '$PROCEDURE' is NOT scheduled to run"
    exit 1
  fi
  ;;

*)
  echo "Error: Invalid command: $ACTION"
  echo ""
  show_help
  exit 1
  ;;
esac
