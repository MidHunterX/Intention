#!/usr/bin/env bash

ACTION=$1

PROTOCOL="xoscrp"
cache_file="$HOME/.cache/${PROTOCOL}"

show_init_help() {
    cat <<EOF
The script needs access to a shared directory that both Linux and Windows can access.
This is typically a mounted Windows partition or network share.

Example locations:
    /mnt/windows/          # Mounted Windows partition
    /media/user/shared/    # Shared network drive
    /home/user/shared/     # Shared directory (if using tools like Shared Folders in VM)

After initialization, place your PowerShell scripts in the procedures directory
on the Windows side, and they will be detectable by this script.
EOF
}

# ================================ [ INIT ] ================================ #

set_shared_location() {
    read -r -p 'Enter path to your shared path/mount point: ' partition
    # sanitize mount point name, ensure existence and write to cache
    [[ $partition != /* ]] && partition="/$partition"
    if [ ! -d "$partition" ]; then
        echo "Invalid mountpoint: $partition"
        exit 1
    fi
    echo "$partition" >"$cache_file"
}

# ENSURE: save windows mountpoint in cache
if [ ! -f "$cache_file" ]; then
    show_init_help
    set_shared_location
fi

get_shared_location() {
    [ ! -f "$cache_file" ] && set_shared_location
    local location
    location=$(cat "$cache_file")
    echo "$location"
}

# REQUIRED: Shared Mountpoint
shared_location=$(get_shared_location)
if [ ! -d "$shared_location" ]; then
    echo "Location does not exist: $shared_location"
    exit 1
fi

# ENSURE: shared communication and procedure directories
message_queue="${shared_location}/.${PROTOCOL}/message_queue/"
[ ! -d "${message_queue}" ] && mkdir -p "${message_queue}"

procedures="${shared_location}/.${PROTOCOL}/procedures/"
[ ! -d "${procedures}" ] && mkdir -p "${procedures}"

# =============================== [ ACTION ] =============================== #

is_procedure_available_windows() {
    [[ -f "${procedures}/${PROCEDURE}.ps1" ]] && return 0
    return 1
}

is_procedure_available_linux() {
    [[ -f "${procedures}/${PROCEDURE}.sh" ]] && return 0
    return 1
}

get_available_procedures() {
    local proc_files
    proc_files=$(ls "${procedures}")
    for file in $proc_files; do
        if [[ $file == *.ps1 ]]; then
            echo -e "${file%.ps1}\tWindows"
        elif [[ $file == *.sh ]]; then
            echo -e "${file%.sh}\tLinux"
        fi
    done
}

show_help() {
    cat <<EOF
Cross-OS Procedure Manager

Manages procedures that run automatically when booting into Windows.
Uses shared directory: $shared_location

USAGE:
    intention <OPTIONS> <PROCEDURE>

OPTIONS:
    -l  (--list)                  # List available procedures
    -h  (--help)                  # Show this help message
    -i  (--init)                  # Reconfigure shared location

PROCEDURES:
    Procedures are PowerShell scripts located in:
    ${procedures}
    List available procedures with 'list' command

EXAMPLES:
    intention --init              # Change shared location
    intention --list              # Show available procedures
    intention gaming_mode         # Reboot and run gaming_mode setup
EOF
}

# =============================== [ ACTION ] =============================== #

# REQUIRED: ACTION
if [[ -z "$ACTION" ]]; then
    show_help
    exit 0
fi

case "$ACTION" in
"-h" | "--help")
    show_help
    exit 0
    ;;

"-i" | "--init")
    show_init_help
    echo ""
    set_shared_location
    echo "Shared location updated successfully."
    exit 0
    ;;

"-l" | "--list")
    get_available_procedures
    exit 0
    ;;
esac

# ============================== [ PROCEDURE ] ============================== #

PROCEDURE=$ACTION

# SANITIZE: remote procedure name
if [[ ! "$PROCEDURE" =~ ^[A-Za-z0-9_-]+$ ]]; then
    echo "Error: Invalid procedure name: $PROCEDURE"
    echo "Valid characters: A-Z, a-z, 0-9, _, -"
    exit 1
fi

# ACTION: run procedure
if is_procedure_available_windows; then
    echo "Rebooting to Windows and running procedure: $PROCEDURE"
    touch "${message_queue}/${PROCEDURE}"
    # eg $windows_title = 'Windows Boot Manager (on /dev/nvme0n1p1)'
    windows_title=$(sudo grep -i windows /boot/grub/grub.cfg | cut -d "'" -f 2)
    sudo grub-reboot "$windows_title"
    reboot
    exit 0

elif is_procedure_available_linux; then
    bash "${procedures}/${PROCEDURE}.sh"
    exit 0

else
    echo "Error: Procedure '$PROCEDURE' is not available"
    echo "Available procedures:"
    get_available_procedures | sed 's/^/  - /'
    exit 1
fi
