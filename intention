#!/usr/bin/env bash

ACTION=$1
PROCEDURE=$2

PROTOCOL="xoscrp"
cache_file="$HOME/.cache/${PROTOCOL}"

show_init_help() {
  cat <<EOF
The script needs access to a shared directory that both Linux and Windows can access.
This is typically a mounted Windows partition or network share.

Example locations:
    /mnt/windows/          # Mounted Windows partition
    /media/user/shared/    # Shared network drive
    /home/user/shared/     # Shared directory (if using tools like Shared Folders in VM)

The directory will contain:
    ${comms_dir}    # Communication queue (marker files)
    ${proc_dir}     # Procedure scripts (.ps1 files)

After initialization, place your PowerShell scripts in the procedures directory
on the Windows side, and they will be detectable by this script.
EOF
}

# ================================ [ INIT ] ================================ #

set_shared_location() {
  read -r -p 'Enter path to your shared path/mount point: ' partition
  # sanitize mount point name, ensure existence and write to cache
  [[ $partition != /* ]] && partition="/$partition"
  if [ ! -d $partition ]; then
    echo "Invalid mountpoint: $partition"
    exit 1
  fi
  echo $partition >$cache_file
}

# ENSURE: save windows mountpoint in cache
if [ ! -f $cache_file ]; then
  show_init_help
  set_shared_location
fi

get_shared_location() {
  [ ! -f $cache_file ] && set_shared_location
  local location=$(cat $cache_file)
  echo $location
}

# REQUIRED: Shared Mountpoint
shared_location=$(get_shared_location)
if [ ! -d $shared_location ]; then
  echo "Location does not exist: $shared_location"
  exit 1
fi

# ENSURE: shared communication and procedure directories
message_queue="${shared_location}/.${PROTOCOL}/message_queue/"
[ ! -d "${message_queue}" ] && mkdir -p "${message_queue}"

procedures="${shared_location}/.${PROTOCOL}/procedures/"
[ ! -d "${procedures}" ] && mkdir -p "${procedures}"

# =============================== [ ACTION ] =============================== #

is_procedure_available() {
  [[ -f "${procedures}/${PROCEDURE}.ps1" ]] && return 0
  return 1
}

is_procedure_called() {
  [[ -f "${message_queue}/${PROCEDURE}" ]] && return 0
  return 1
}

get_available_procedures() {
  echo "$(ls ${procedures} | cut -d '.' -f 1)"
}

show_help() {
  cat <<EOF
Cross-OS Procedure Manager

Manages procedures that run automatically when booting into Windows.
Uses shared directory: $shared_location

USAGE:
    $0 [COMMAND] [PROCEDURE]

COMMANDS:
    list                    List all available procedures
    run [PROCEDURE]         Reboot to Windows and run specified procedure
    run                     Reboot to Windows without running any procedure
    set <PROCEDURE>         Mark procedure to run on next Windows boot
    unset <PROCEDURE>       Remove mark from procedure
    status <PROCEDURE>      Check if procedure is marked to run
    help                    Show this help message
    init                    Reconfigure shared location

PROCEDURES:
    Procedures are PowerShell scripts located in:
    ${windows_proc_dir}
    List available procedures with 'list' command

EXAMPLES:
    $0 list                 # Show available procedures
    $0 run gaming_mode      # Reboot and run gaming_mode setup
    $0 set gaming_mode      # Mark gaming_mode setup for next boot
    $0 status gaming_mode   # Check if gaming_mode setup is scheduled
    $0 unset gaming_mode    # Cancel gaming_mode setup
    $0 init                 # Change shared location
EOF
}

# ============================= [ ACTION (2) ] ============================= #

# REQUIRED: ACTION
if [[ -z "$ACTION" ]]; then
  show_help
  exit 0
fi

case "$ACTION" in
"help" | "-h" | "--help")
  show_help
  exit 0
  ;;

"init")
  show_init_help
  echo ""
  set_shared_location
  echo "Shared location updated successfully."
  echo "New location: $(cat $cache_file)"
  exit 0
  ;;

"list")
  get_available_procedures
  exit 0
  ;;

"run")
  # case: reboot without PROCEDURE
  if [[ -z "$PROCEDURE" ]]; then
    echo "Rebooting to Windows without running any procedure..."
    # eg $windows_title = 'Windows Boot Manager (on /dev/nvme0n1p1)'
    windows_title=$(sudo grep -i windows /boot/grub/grub.cfg | cut -d "'" -f 2)
    sudo grub-reboot "$windows_title"
    reboot
    exit 0
  fi

  # case: reboot with PROCEDURE
  if is_procedure_available; then
    echo "Rebooting to Windows and running procedure: $PROCEDURE"
    touch "${message_queue}/${PROCEDURE}"
    # eg $windows_title = 'Windows Boot Manager (on /dev/nvme0n1p1)'
    windows_title=$(sudo grep -i windows /boot/grub/grub.cfg | cut -d "'" -f 2)
    sudo grub-reboot "$windows_title"
    reboot
    exit 0
  else
    echo "Error: Procedure '$PROCEDURE' is not available"
    echo "Available procedures:"
    get_available_procedures | sed 's/^/  - /'
    exit 1
  fi
  ;;
esac

# ============================= [ ACTION (3) ] ============================= #

# REQUIRED: PROCEDURE
if [[ -z "$PROCEDURE" ]]; then
  echo "Error: Procedure name is required for action '$ACTION'"
  echo ""
  show_help
  exit 1
fi

# SANITIZE: remote procedure name
if [[ ! "$PROCEDURE" =~ ^[A-Za-z0-9_-]+$ ]]; then
  echo "Error: Invalid procedure name: $PROCEDURE"
  echo "Valid characters: A-Z, a-z, 0-9, _, -"
  exit 1
fi

case "$ACTION" in
"set")
  if is_procedure_available; then
    touch "${message_queue}/${PROCEDURE}"
    echo "Procedure '$PROCEDURE' scheduled for next Windows boot"
  else
    echo "Error: Procedure '$PROCEDURE' is not available"
    echo "Available procedures:"
    get_available_procedures | sed 's/^/  - /'
    exit 1
  fi
  ;;

"unset")
  if is_procedure_called; then
    rm "${message_queue}/${PROCEDURE}"
    echo "Procedure '$PROCEDURE' removed from schedule"
  else
    echo "Error: Procedure '$PROCEDURE' is not scheduled"
    exit 1
  fi
  ;;

"status")
  if is_procedure_called; then
    echo "Procedure '$PROCEDURE' is scheduled to run on next Windows boot"
  else
    echo "Procedure '$PROCEDURE' is NOT scheduled to run"
    exit 1
  fi
  ;;

*)
  echo "Error: Invalid command: $ACTION"
  echo ""
  show_help
  exit 1
  ;;
esac
