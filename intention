#!/usr/bin/env bash

COMMAND=$1
PROCEDURE=$2

PROTOCOL="xoscrp"
cache_file="$HOME/.cache/${PROTOCOL}"
comms_dir=".${PROTOCOL}/message_queue/"
proc_dir=".${PROTOCOL}/procedures/"

# ================================ [ INIT ] ================================ #

set_shared_location() {
  read -r -p 'Enter path to your shared path/mount point: ' partition
  # sanitize mount point name, ensure existence and write to cache
  [[ $partition != /* ]] && partition="/$partition"
  if [ ! -d $partition ]; then
    echo "Invalid mountpoint: $partition"
    exit 1
  fi
  echo $partition >$cache_file
}

# ENSURE: save windows mountpoint in cache
if [ ! -f $cache_file ]; then
  set_shared_location
fi

get_shared_location() {
  [ ! -f $cache_file ] && set_shared_location
  windows_mountpoint=$(cat $cache_file)
  echo $windows_mountpoint
}

# ENSURE: windows_comm_dir exists
windows_mountpoint=$(get_shared_location)
windows_comm_dir="${windows_mountpoint}/${comms_dir}"
[ ! -d "${windows_comm_dir}" ] && mkdir -p "${windows_comm_dir}"

# =========================== [ COMMUNICATIONS ] =========================== #

get_available_procedures() {
  echo "$(ls $windows_proc_dir | cut -d '.' -f 1)"
}

# CASE: without remote procedure
windows_proc_dir="${windows_mountpoint}/${proc_dir}"
[[ -z "$PROCEDURE" ]] && {
  echo "No procedure specified"
  echo "Available Procedures (Windows):"
  get_available_procedures
  echo "Usage: intention <command> <procedure>"
  echo "Example: intention [set|unset] gaming_mode"
  exit 0
}

# SANITIZE: remote procedure name
[[ ! "$PROCEDURE" =~ ^[A-Za-z0-9_-]+$ ]] && {
  echo "Invalid procedure"
  exit 1
}

# =============================== [ ACTION ] =============================== #

is_procedure_available() {
  [[ -f "${windows_proc_dir}/${PROCEDURE}.ps1" ]] && return 0
  return 1
}

is_procedure_called() {
  [[ -f "${windows_comm_dir}/${PROCEDURE}" ]] && return 0
  return 1
}

# ACTION: Run remote procedure
if [[ "$COMMAND" == "set" ]]; then
  if is_procedure_available; then
    touch "${windows_comm_dir}/${PROCEDURE}"
  else
    echo "Procedure $PROCEDURE is not available"
  fi

# ACTION: Delete remote procedure
elif [[ "$COMMAND" == "unset" ]]; then
  if is_procedure_called; then
    rm "${windows_comm_dir}/${PROCEDURE}"
  else
    echo "Procedure $PROCEDURE is not set on Windows"
  fi

# ACTION: List remote procedures
elif [[ "$COMMAND" == "list" ]]; then
  echo "Available Procedures (Windows):"
  get_available_procedures

# ACTION: Status of remote procedure
elif [[ "$COMMAND" == "status" ]]; then
  if is_procedure_called; then
    echo "Procedure $PROCEDURE is set on Windows"
  else
    echo "Procedure $PROCEDURE is not set on Windows"
  fi

# ACTION (CRITICAL): Reboot to Windows
elif [[ "$COMMAND" == "reboot" ]]; then
  if is_procedure_available; then
    touch "${windows_comm_dir}/${PROCEDURE}"
    # eg $windows_title = 'Windows Boot Manager (on /dev/nvme0n1p1)'
    windows_title=$(sudo grep -i windows /boot/grub/grub.cfg | cut -d "'" -f 2)
    sudo grub-reboot "$windows_title"
    sudo reboot
  else
    echo "Procedure $PROCEDURE is not available"
  fi

# ACTION: Invalid command
else
  echo "Invalid command: $COMMAND"
  exit 1
fi
