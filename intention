#!/usr/bin/env bash

ACTION=$1

PROTOCOL="xoscrp"
cache_file="$HOME/.cache/${PROTOCOL}"

show_init_help() {
  cat <<EOF
The script needs access to a shared directory that both Linux and Windows can access.
This is typically a mounted Windows partition or network share.

Example locations:
    /mnt/windows/          # Mounted Windows partition
    /media/user/shared/    # Shared network drive
    /home/user/shared/     # Shared directory (if using tools like Shared Folders in VM)

After initialization, place your PowerShell scripts in the procedures directory
on the Windows side, and they will be detectable by this script.
EOF
}

# ================================ [ INIT ] ================================ #

set_shared_location() {
  read -r -p 'Enter path to your shared path/mount point: ' partition
  # sanitize mount point name, ensure existence and write to cache
  [[ $partition != /* ]] && partition="/$partition"
  if [ ! -d "$partition" ]; then
    echo "Invalid mountpoint: $partition"
    exit 1
  fi
  echo "$partition" >"$cache_file"
}

# ENSURE: save windows mountpoint in cache
if [ ! -f "$cache_file" ]; then
  show_init_help
  set_shared_location
fi

get_shared_location() {
  [ ! -f "$cache_file" ] && set_shared_location
  local location
  location=$(cat "$cache_file")
  echo "$location"
}

# REQUIRED: Shared Mountpoint
shared_location=$(get_shared_location)
if [ ! -d "$shared_location" ]; then
  echo "Location does not exist: $shared_location"
  exit 1
fi

# ENSURE: shared communication and procedure directories
message_queue="${shared_location}/.${PROTOCOL}/message_queue/"
[ ! -d "${message_queue}" ] && mkdir -p "${message_queue}"

procedures="${shared_location}/.${PROTOCOL}/procedures/"
[ ! -d "${procedures}" ] && mkdir -p "${procedures}"

# =============================== [ ACTION ] =============================== #

is_procedure_available_windows() {
  [[ -f "${procedures}/${PROCEDURE}.ps1" ]] && return 0
  return 1
}

is_procedure_available_linux() {
  [[ -f "${procedures}/${PROCEDURE}.sh" ]] && return 0
  return 1
}

get_available_procedures() {
  local proc_files
  proc_files=$(ls "${procedures}")
  for file in $proc_files; do
    if [[ $file == *.ps1 ]]; then
      echo -e "${file%.ps1}\tWindows"
    elif [[ $file == *.sh ]]; then
      echo -e "${file%.sh}\tLinux"
    else
      echo -e "${file}\tUnknown"
    fi
  done
}

show_help() {
  cat <<EOF
Cross-OS Procedure Manager

Manages procedures that run automatically when booting into Windows.
Uses shared directory: $shared_location

USAGE:
    intention <OPTIONS> <PROCEDURE>

OPTIONS:
    -l  (--list)                  # List available procedures
    -h  (--help)                  # Show this help message
    -i  (--init)                  # Reconfigure shared location

PROCEDURES:
    Procedures are PowerShell scripts located in:
    ${procedures}
    List available procedures with 'list' command

EXAMPLES:
    intention --init              # Change shared location
    intention --list              # Show available procedures
    intention gaming_mode         # Reboot and run gaming_mode setup
EOF
}

# =============================== [ ACTION ] =============================== #

# REQUIRED: ACTION
if [[ -z "$ACTION" ]]; then
  show_help
  exit 0
fi

case "$ACTION" in
"-h" | "--help")
  show_help
  exit 0
  ;;

"-i" | "--init")
  show_init_help
  echo ""
  set_shared_location
  echo "Shared location updated successfully."
  exit 0
  ;;

"-l" | "--list")
  get_available_procedures
  exit 0
  ;;
esac

# ============================== [ PROCEDURE ] ============================== #

PROCEDURE=$ACTION

# SANITIZE: remote procedure name
if [[ ! "$PROCEDURE" =~ ^[A-Za-z0-9_-]+$ ]]; then
  echo "Error: Invalid procedure name: $PROCEDURE"
  echo "Valid characters: A-Z, a-z, 0-9, _, -"
  exit 1
fi

# ACTION: run procedure
if is_procedure_available_windows; then
  echo "Rebooting to Windows and running procedure: $PROCEDURE"
  touch "${message_queue}/${PROCEDURE}"
  # eg $windows_title = 'Windows Boot Manager (on /dev/nvme0n1p1)'
  windows_title=$(sudo grep -i windows /boot/grub/grub.cfg | cut -d "'" -f 2)
  sudo grub-reboot "$windows_title"
  reboot
  exit 0

elif is_procedure_available_linux; then
  bash "${procedures}/${PROCEDURE}.sh"
  exit 0

else
  echo "Error: Procedure '$PROCEDURE' is not available"
  echo "Available procedures:"
  get_available_procedures | sed 's/^/  - /'
  exit 1
fi
